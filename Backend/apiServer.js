/**
 * Argus Defense API Server
 * Serves OpenMHz stream data to the frontend
 */

const express = require('express');
const cors = require('cors');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const libp2pService = require('./libp2pService');

const app = express();
const PORT = process.env.API_PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// In-memory tracking of active listeners
const activeListeners = new Map();

// libp2p initialization flag
let libp2pInitialized = false;

// Auto-publish configuration
const AUTO_PUBLISH_ENABLED = process.env.LIBP2P_AUTO_PUBLISH === 'true';
const AUTO_PUBLISH_LIMIT = parseInt(process.env.LIBP2P_AUTO_PUBLISH_LIMIT || '5', 10);
let lastKnownStreams = new Set();
let streamsWatcher = null;

/**
 * Load streams data from the JSON file generated by ingest_openmhz.py
 */
async function loadStreamsData() {
  try {
    const dataPath = path.join(__dirname, 'openmhz/streams.json');
    const data = await fs.readFile(dataPath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error loading streams data:', error);
    return null;
  }
}

/**
 * GET /api/streams
 * Returns the list of all available streams with metadata and wallet addresses
 */
app.get('/api/streams', async (req, res) => {
  try {
    const data = await loadStreamsData();

    if (!data) {
      return res.status(500).json({
        error: 'Failed to load streams data'
      });
    }

    // Flatten all streams from all systems
    const allStreams = [];

    for (const [systemKey, systemData] of Object.entries(data)) {
      if (systemKey === 'last_updated') continue;

      if (systemData.streams && Array.isArray(systemData.streams)) {
        // Add listener count from activeListeners and P2P info
        const enrichedStreams = systemData.streams.map(stream => ({
          ...stream,
          active_listeners: activeListeners.get(stream.stream_id) || 0,
          p2p_available: libp2pService.isStreamPublished(stream.stream_id),
          p2p_peer_count: libp2pService.getStreamPeerCount(stream.stream_id),
          system_info: {
            system_id: systemData.system_id,
            total_streams: systemData.total_streams,
            total_talkgroups: systemData.total_talkgroups
          }
        }));

        allStreams.push(...enrichedStreams);
      }
    }

    res.json({
      total_streams: allStreams.length,
      last_updated: data.last_updated,
      streams: allStreams
    });
  } catch (error) {
    console.error('Error in /api/streams:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * GET /api/streams/:systemId
 * Returns streams for a specific system
 */
app.get('/api/streams/:systemId', async (req, res) => {
  try {
    const { systemId } = req.params;
    const data = await loadStreamsData();

    if (!data) {
      return res.status(500).json({
        error: 'Failed to load streams data'
      });
    }

    const systemData = data[systemId];

    if (!systemData) {
      return res.status(404).json({
        error: 'System not found',
        systemId
      });
    }

    // Add listener count from activeListeners and P2P info
    const enrichedStreams = systemData.streams.map(stream => ({
      ...stream,
      active_listeners: activeListeners.get(stream.stream_id) || 0,
      p2p_available: libp2pService.isStreamPublished(stream.stream_id),
      p2p_peer_count: libp2pService.getStreamPeerCount(stream.stream_id)
    }));

    res.json({
      system_id: systemData.system_id,
      total_streams: systemData.total_streams,
      total_talkgroups: systemData.total_talkgroups,
      talkgroups: systemData.talkgroups,
      streams: enrichedStreams,
      generated_at: systemData.generated_at
    });
  } catch (error) {
    console.error(`Error in /api/streams/${req.params.systemId}:`, error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * GET /api/stream/:streamId
 * Returns details for a specific stream
 */
app.get('/api/stream/:streamId', async (req, res) => {
  try {
    const { streamId } = req.params;
    const data = await loadStreamsData();

    if (!data) {
      return res.status(500).json({
        error: 'Failed to load streams data'
      });
    }

    // Search for the stream across all systems
    let foundStream = null;
    let foundSystem = null;

    for (const [systemKey, systemData] of Object.entries(data)) {
      if (systemKey === 'last_updated') continue;

      if (systemData.streams && Array.isArray(systemData.streams)) {
        foundStream = systemData.streams.find(s => s.stream_id === streamId);
        if (foundStream) {
          foundSystem = systemData;
          break;
        }
      }
    }

    if (!foundStream) {
      return res.status(404).json({
        error: 'Stream not found',
        streamId
      });
    }

    res.json({
      ...foundStream,
      active_listeners: activeListeners.get(streamId) || 0,
      p2p_available: libp2pService.isStreamPublished(streamId),
      p2p_peer_count: libp2pService.getStreamPeerCount(streamId),
      system_info: {
        system_id: foundSystem.system_id,
        total_streams: foundSystem.total_streams,
        total_talkgroups: foundSystem.total_talkgroups
      }
    });
  } catch (error) {
    console.error(`Error in /api/stream/${req.params.streamId}:`, error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * POST /api/listen/start
 * Start tracking a listener for a stream
 */
app.post('/api/listen/start', (req, res) => {
  try {
    const { streamId, listenerId } = req.body;

    if (!streamId) {
      return res.status(400).json({
        error: 'streamId is required'
      });
    }

    const currentCount = activeListeners.get(streamId) || 0;
    activeListeners.set(streamId, currentCount + 1);

    console.log(`Listener started for stream ${streamId}. Total listeners: ${currentCount + 1}`);

    res.json({
      success: true,
      streamId,
      listenerId: listenerId || 'anonymous',
      active_listeners: currentCount + 1
    });
  } catch (error) {
    console.error('Error in /api/listen/start:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * POST /api/listen/stop
 * Stop tracking a listener for a stream
 */
app.post('/api/listen/stop', (req, res) => {
  try {
    const { streamId, listenerId } = req.body;

    if (!streamId) {
      return res.status(400).json({
        error: 'streamId is required'
      });
    }

    const currentCount = activeListeners.get(streamId) || 0;
    const newCount = Math.max(0, currentCount - 1);

    if (newCount === 0) {
      activeListeners.delete(streamId);
    } else {
      activeListeners.set(streamId, newCount);
    }

    console.log(`Listener stopped for stream ${streamId}. Total listeners: ${newCount}`);

    res.json({
      success: true,
      streamId,
      listenerId: listenerId || 'anonymous',
      active_listeners: newCount
    });
  } catch (error) {
    console.error('Error in /api/listen/stop:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * GET /api/systems
 * Returns the list of available systems
 */
app.get('/api/systems', async (req, res) => {
  try {
    const data = await loadStreamsData();

    if (!data) {
      return res.status(500).json({
        error: 'Failed to load streams data'
      });
    }

    const systems = [];

    for (const [systemKey, systemData] of Object.entries(data)) {
      if (systemKey === 'last_updated') continue;

      systems.push({
        system_id: systemData.system_id,
        total_streams: systemData.total_streams,
        total_talkgroups: systemData.total_talkgroups
      });
    }

    res.json({
      total_systems: systems.length,
      systems
    });
  } catch (error) {
    console.error('Error in /api/systems:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * POST /api/libp2p/publish
 * Publish a stream to libp2p
 */
app.post('/api/libp2p/publish', async (req, res) => {
  try {
    const { streamId, audioUrl, metadata } = req.body;

    if (!streamId || !audioUrl) {
      return res.status(400).json({
        error: 'streamId and audioUrl are required'
      });
    }

    // Initialize libp2p if not already initialized
    if (!libp2pInitialized) {
      await libp2pService.startPublisher();
      libp2pInitialized = true;
    }

    // Check if stream exists in streams.json
    const data = await loadStreamsData();
    let foundStream = null;

    for (const [systemKey, systemData] of Object.entries(data)) {
      if (systemKey === 'last_updated') continue;
      if (systemData.streams && Array.isArray(systemData.streams)) {
        foundStream = systemData.streams.find(s => s.stream_id === streamId);
        if (foundStream) break;
      }
    }

    // Publish to libp2p
    const result = await libp2pService.publishStream(
      streamId,
      audioUrl,
      metadata || (foundStream ? foundStream.metadata : {})
    );

    console.log(`ðŸ“¡ Stream ${streamId} published to libp2p`);

    res.json({
      success: true,
      streamId,
      topic: result.topic,
      peerId: result.peerId,
      message: 'Stream published to libp2p network'
    });
  } catch (error) {
    console.error('Error in /api/libp2p/publish:', error);
    res.status(500).json({
      error: 'Failed to publish stream',
      message: error.message
    });
  }
});

/**
 * GET /api/libp2p/status
 * Get publisher status and info
 */
app.get('/api/libp2p/status', (req, res) => {
  try {
    const info = libp2pService.getPublisherInfo();

    res.json({
      ...info,
      initialized: libp2pInitialized
    });
  } catch (error) {
    console.error('Error in /api/libp2p/status:', error);
    res.status(500).json({
      error: 'Failed to get status',
      message: error.message
    });
  }
});

/**
 * GET /api/libp2p/streams
 * Get active P2P streams
 */
app.get('/api/libp2p/streams', (req, res) => {
  try {
    const streams = libp2pService.getActiveStreams();

    res.json({
      total_streams: streams.length,
      streams
    });
  } catch (error) {
    console.error('Error in /api/libp2p/streams:', error);
    res.status(500).json({
      error: 'Failed to get streams',
      message: error.message
    });
  }
});

/**
 * POST /api/libp2p/stop/:streamId
 * Stop publishing a specific stream
 */
app.post('/api/libp2p/stop/:streamId', async (req, res) => {
  try {
    const { streamId } = req.params;

    if (!libp2pInitialized) {
      return res.status(400).json({
        error: 'libp2p publisher not initialized'
      });
    }

    await libp2pService.stopStream(streamId);

    console.log(`ðŸ›‘ Stream ${streamId} stopped on libp2p`);

    res.json({
      success: true,
      streamId,
      message: 'Stream stopped'
    });
  } catch (error) {
    console.error(`Error in /api/libp2p/stop/${req.params.streamId}:`, error);
    res.status(500).json({
      error: 'Failed to stop stream',
      message: error.message
    });
  }
});

/**
 * POST /api/libp2p/start
 * Manually start the libp2p publisher
 */
app.post('/api/libp2p/start', async (req, res) => {
  try {
    if (libp2pInitialized) {
      return res.json({
        success: true,
        message: 'Publisher already running',
        info: libp2pService.getPublisherInfo()
      });
    }

    const info = await libp2pService.startPublisher();
    libp2pInitialized = true;

    console.log('ðŸš€ libp2p publisher started via API');

    res.json({
      success: true,
      message: 'Publisher started',
      info
    });
  } catch (error) {
    console.error('Error in /api/libp2p/start:', error);
    res.status(500).json({
      error: 'Failed to start publisher',
      message: error.message
    });
  }
});

/**
 * POST /api/libp2p/stop
 * Stop the libp2p publisher
 */
app.post('/api/libp2p/stop', async (req, res) => {
  try {
    if (!libp2pInitialized) {
      return res.json({
        success: true,
        message: 'Publisher not running'
      });
    }

    await libp2pService.stopPublisher();
    libp2pInitialized = false;

    console.log('ðŸ›‘ libp2p publisher stopped via API');

    res.json({
      success: true,
      message: 'Publisher stopped'
    });
  } catch (error) {
    console.error('Error in /api/libp2p/stop:', error);
    res.status(500).json({
      error: 'Failed to stop publisher',
      message: error.message
    });
  }
});

/**
 * Health check endpoint
 */
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    active_streams: activeListeners.size,
    libp2p_status: libp2pService.getPublisherInfo().status
  });
});

/**
 * Auto-publish new streams to libp2p
 * Watches streams.json for changes and automatically publishes new streams
 */
async function autoPublishNewStreams() {
  try {
    const data = await loadStreamsData();
    if (!data) {
      return;
    }

    // Ensure libp2p is initialized
    if (!libp2pInitialized) {
      await libp2pService.startPublisher();
      libp2pInitialized = true;
      console.log('ðŸš€ libp2p auto-publisher started');
    }

    const currentStreams = new Set();
    const newStreams = [];

    // Collect all stream IDs
    for (const [systemKey, systemData] of Object.entries(data)) {
      if (systemKey === 'last_updated') continue;

      if (systemData.streams && Array.isArray(systemData.streams)) {
        for (const stream of systemData.streams) {
          currentStreams.add(stream.stream_id);

          // Check if this is a new stream
          if (!lastKnownStreams.has(stream.stream_id)) {
            newStreams.push(stream);
          }
        }
      }
    }

    // Publish new streams (up to limit)
    if (newStreams.length > 0) {
      console.log(`ðŸ“¡ Found ${newStreams.length} new stream(s)`);

      const streamsToPublish = newStreams.slice(0, AUTO_PUBLISH_LIMIT);

      for (const stream of streamsToPublish) {
        try {
          // Check if already published
          if (libp2pService.isStreamPublished(stream.stream_id)) {
            console.log(`â­ï¸  Stream ${stream.stream_id} already published, skipping`);
            continue;
          }

          await libp2pService.publishStream(
            stream.stream_id,
            stream.audio_url,
            stream.metadata || {}
          );
          console.log(`âœ… Auto-published stream: ${stream.stream_id} (${stream.name})`);
        } catch (error) {
          console.error(`âŒ Failed to auto-publish stream ${stream.stream_id}:`, error.message);
        }
      }

      if (newStreams.length > AUTO_PUBLISH_LIMIT) {
        console.log(`âš ï¸  Limited auto-publish to ${AUTO_PUBLISH_LIMIT} streams (${newStreams.length - AUTO_PUBLISH_LIMIT} skipped)`);
      }
    }

    // Update known streams
    lastKnownStreams = currentStreams;
  } catch (error) {
    console.error('âŒ Error in auto-publish:', error);
  }
}

/**
 * Start watching for stream updates
 */
function startStreamsWatcher() {
  if (!AUTO_PUBLISH_ENABLED) {
    console.log('â„¹ï¸  libp2p auto-publish is disabled');
    return;
  }

  console.log(`ðŸ” Starting auto-publish watcher (limit: ${AUTO_PUBLISH_LIMIT} streams per update)`);

  const streamsPath = path.join(__dirname, 'openmhz/streams.json');

  // Initial scan
  autoPublishNewStreams().catch(error => {
    console.error('Error in initial auto-publish:', error);
  });

  // Watch for file changes
  streamsWatcher = fsSync.watch(streamsPath, (eventType) => {
    if (eventType === 'change') {
      console.log('ðŸ“ Detected streams.json update');
      autoPublishNewStreams().catch(error => {
        console.error('Error in auto-publish:', error);
      });
    }
  });
}

/**
 * Stop the streams watcher
 */
function stopStreamsWatcher() {
  if (streamsWatcher) {
    streamsWatcher.close();
    streamsWatcher = null;
    console.log('ðŸ›‘ Stopped streams watcher');
  }
}

// Start the server
app.listen(PORT, () => {
  console.log(`\nðŸš€ Argus Defense API Server running on http://localhost:${PORT}`);
  console.log('\nAvailable endpoints:');
  console.log(`  GET  http://localhost:${PORT}/api/streams`);
  console.log(`  GET  http://localhost:${PORT}/api/streams/:systemId`);
  console.log(`  GET  http://localhost:${PORT}/api/stream/:streamId`);
  console.log(`  GET  http://localhost:${PORT}/api/systems`);
  console.log(`  POST http://localhost:${PORT}/api/listen/start`);
  console.log(`  POST http://localhost:${PORT}/api/listen/stop`);
  console.log(`  GET  http://localhost:${PORT}/health`);
  console.log('\nlibp2p endpoints:');
  console.log(`  POST http://localhost:${PORT}/api/libp2p/start`);
  console.log(`  POST http://localhost:${PORT}/api/libp2p/stop`);
  console.log(`  POST http://localhost:${PORT}/api/libp2p/publish`);
  console.log(`  POST http://localhost:${PORT}/api/libp2p/stop/:streamId`);
  console.log(`  GET  http://localhost:${PORT}/api/libp2p/status`);
  console.log(`  GET  http://localhost:${PORT}/api/libp2p/streams`);
  console.log('\n');

  // Start auto-publish watcher if enabled
  startStreamsWatcher();
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\n\nShutting down API server...');

  // Stop streams watcher
  stopStreamsWatcher();

  // Stop libp2p if running
  if (libp2pInitialized) {
    console.log('Stopping libp2p publisher...');
    try {
      await libp2pService.stopPublisher();
    } catch (error) {
      console.error('Error stopping libp2p:', error);
    }
  }

  process.exit(0);
});
